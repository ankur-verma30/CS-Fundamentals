âœ… Event-Driven Architecture (EDA)

â¤ Services don't call each other directly.
â¤ Instead, they communicate via events through an event bus.
â¤ A service produces an event indicating something has changed.
â¤ Other services (subscribers) consume relevant events and may trigger further events.
â¤ Similar to Publish-Subscribe (Pub/Sub), but with state changes and decoupled workflows.

ğŸ§  Core Components
â¤ Event Bus: Central system to which services publish or subscribe.
â¤ Producers: Services emitting events.
â¤ Consumers: Services acting upon received events.
â¤ Event Store: (Optional) Persists all emitted events for auditing or replay.

ğŸ® Example Use Case (Gaming)
â¤ In games like Counter-Strike, player actions are sent as timestamped events.
â¤ Server replays event history to determine if a shot was valid based on past player positions.

ğŸ“Œ Key Features
1. Local Event Storage:
â¤ Each service can store events relevant to it.
â¤ Increases availability.

2. Persistence:
â¤ Services can maintain state by replaying events.
â¤ Enables time-travel debugging or restoring to previous states.

3. Replay and Replacement:
â¤ New services can replay historical events to sync with existing ones.
â¤ Easy version upgrades or replacements.

âœ… Advantages
â¤ High availability: Doesnâ€™t rely on every service being live.
â¤ Resilience: New services can catch up using event history.
â¤ Debugging: Can replay events to debug or fix issues.
â¤ Decoupling: Services are loosely coupled.
â¤ Transactional guarantees:
1. At most once: e.g., welcome email.
2. At least once: e.g., invoice email.


âŒ Disadvantages
Inconsistent State:
â¤ Different services may have outdated or mismatched data.

Difficult Debugging:
â¤ Hard to trace event flow (no direct calls).

External Dependency Limitation:
â¤ Can't replay events if the outcome depends on real-time external systems (e.g., sending emails).

Low Fine-Grained Control:
â¤ Can't directly control target, timeout, or ordering like HTTP.

Security Concerns:
â¤ Over-publishing might leak sensitive state changes.

Complicated Event Management:
â¤ Determining who consumes what and enforcing that is tough.

Event Replay Complexity:
â¤ Replay all â†’ impractical for huge logs.

Diff-based or Undo models needed.
â¤ Event compaction helps manage size.

ğŸ§  Developer Concerns
â¤ Difficult to reason: Hard to understand full system flow just by reading code.
â¤ Hard to revert to request-response: Not easily adaptable if you want synchronous interaction later.

ğŸ“Œ When to Use EDA
Useful when:
â¤ High availability is more important than consistency.
â¤ Services need to evolve independently.
â¤ Replay, auditing, or logging is important.

Not ideal if:
â¤ You need strict request/response flow.
â¤ You rely heavily on real-time external API calls.

ğŸ” Examples
â¤ Git (Commit History) â†’ Event logs
â¤ React â†’ State changes handled via events
â¤ Node.js â†’ Event-driven I/O
â¤ Gaming servers â†’ Process actions via timestamped events