ğŸ”¹ 1. SQL vs NoSQL â€“ Core Differences
ğŸ“˜ SQL (Relational DB)
â¤ Structured schema; normalized data via foreign keys.
â¤ Data split across tables (e.g., Address stored separately from Person).
â¤ Schema rigid: Adding/removing fields requires ALTER operations.
â¤ Supports ACID properties (Atomicity, Consistency, Isolation, Durability).
â¤ Optimized for reads, joins, and transactional systems.

ğŸ“— NoSQL (Document-Oriented DB)
â¤ Flexible schema; data stored as JSON-like documents.
â¤ Nested structures (e.g., address embedded inside user object).
â¤ Schema-less: Easy to add fields like salary to future records only.
â¤ Designed for write-heavy, eventual consistency, and high availability use cases.

ğŸ”¹ 2. Advantages of NoSQL
âœ… Denormalized Structure:
â¤ All related data (e.g., user + address) stored together in one block.
â¤ Faster inserts and reads â€“ no need for joins.

ğŸ”„ Schema Flexibility:
â¤ Can store different fields per document.
â¤ No need to update existing records when schema evolves.

ğŸ“Š Horizontal Partitioning (Sharding):
â¤ Built for scale; distributes data across multiple nodes.
â¤ Supports high availability and load balancing.

ğŸ“ˆ Built for Aggregations:
â¤ Supports metrics like average age, total salary, etc.

ğŸ”¹ 3. Disadvantages of NoSQL
â¤ âŒ Lack of Strong Consistency:
â¤ No ACID guarantees.
â¤ Eventual consistency model (inherent trade-off in CAP theorem).

ğŸ¢ Slower Reads for Specific Fields:
â¤ Reads entire document (even for one field).
â¤ Not optimized for column-specific queries.

ğŸ”— No Implicit Relationships:
â¤ Cannot enforce foreign key constraints.
â¤ Relationships between entities must be managed manually.

ğŸ” Joins are Hard:
â¤ Manual implementation required.
â¤ No built-in support for complex joins like SQL.

ğŸ”¹ 4. Cassandra Architecture: High-Level
â¤ Data stored in a distributed cluster (e.g., 5 nodes).
â¤ Key (not ID) is hashed to determine target node.
â¤ Good hash function ensures uniform distribution and prevents hotspots.
â¤ Poor hash functions may cause data skew (some nodes overloaded).
â¤ Multi-level sharding can help in complex cases (e.g., region-wise routing).

ğŸ”¹ 5. Replication in Cassandra
â¤ To prevent data loss, writes are replicated across N nodes (replication factor).
Example: If request hashes to node 2:
â¤ Data stored in node 2 + next N-1 clockwise nodes (e.g., nodes 3 and 4).
â¤ Redundancy improves fault tolerance and read availability.
â¤ Any replica can serve a read request.

ğŸ”¹ 6. Distributed Consensus & Quorum
ğŸ§  The Problem:
â¤ Write happens to node 5 â†’ supposed to replicate to 1 & 2.
â¤ If 5 crashes and 1 & 2 havenâ€™t received the data yet â†’ read fails â†’ wrong result.

âœ… Quorum (Read/Write):
â¤ Ensures that majority of replicas agree on the same value before returning result.
â¤ Formula: R + W > RF (R = read quorum, W = write quorum, RF = replication factor)
Example: RF = 3 â†’ read from any 2 nodes â†’ take the latest timestamp.

âš ï¸ Risks:
â¤ If not enough nodes have the latest data, inconsistent reads may happen.
However, these situations are rare and acceptable in high-availability setups.

ğŸ”¹ 7. SSTables & Compaction (Write Path in Cassandra)
ğŸ“¥ Memtable (In-Memory):
â¤ Writes are logged in memory sequentially.
â¤ Fast insertion like a log file.
â¤ Periodically flushed to disk as SSTable (Sorted String Table).

ğŸ“‚ SSTable (Persistent):
â¤ Immutable, sorted, disk-based structure.
â¤ Every write creates a new SSTable.
â¤ Updates on same key create duplicate versions in new SSTables.

ğŸ§¹ Compaction:
â¤ Merges SSTables to:
â¤ Keep latest record (based on timestamp)
â¤ Remove duplicate/obsolete versions
â¤ Free up disk space

ğŸª¦ Tombstones:
â¤ Marks a record as deleted.
â¤ During compaction, tombstones trigger deletion of all older versions.
â¤ Ensures deleted data is eventually removed.

ğŸ”¹ 8. When to Use NoSQL?
âœ… Use NoSQL if:
â¤ You have write-heavy workloads
â¤ You prefer schema-less data
â¤ Youâ€™re okay with eventual consistency
â¤ You prioritize availability and scalability
â¤ You require flexible, denormalized structures (e.g., user profiles, logs, sensor data)

âŒ Avoid NoSQL if:
â¤ You need strong consistency (ACID)
â¤ You rely on complex joins/relationships
â¤ Youâ€™re building financial or transactional systems