ğŸ”¸ 1. What is an API?
â¤ API (Application Programmable Interface) is a documented, structured way for external systems to interact with your code.
â¤ Itâ€™s a contract â€“ not about how your code works, but how others can use it.
â¤ Analogy: Like a function that external code can call.

ğŸ§© Example:
GetAdmins(groupID: string) â†’ returns List<Admin>

â¤ May return errors like:
1. Group does not exist
2. Group has been deleted
â¤ Return type: JSON list of Admin objects (e.g., ID, name, etc.)

ğŸ”¸ 2. API Best Practices
âœ… a. Correct Placement
â¤ APIs should be placed within the correct microservice.
â¤ Example: GetAdmins should be part of the Group Service, not User or Messaging.

âœ… b. Clear Naming
â¤ Name APIs after the exact job they perform.
â¤ âŒ Donâ€™t name it getAdmins if it returns both admins & their groups.
â¤ âœ… Rename to getAdminsAndGroups or break into separate APIs.

âœ… c. Parameter Clarity
â¤ Only accept needed parameters.
â¤ Donâ€™t overload APIs with irrelevant params.
â¤ If the goal changes (e.g., verifying admin status), use a new function name like checkAdmins.

ğŸ”¸ 3. Response Design
â¤ Return only what is required.
â¤ Avoid bloated responses like huge objects â€œjust in case.â€
â¤ Large responses:
1. Increase bandwidth
2. Confuse API consumers

ğŸ”¸ 4. Error Handling
â¤ Define meaningful, specific errors (not just generic 500s)
Example:
âœ… GroupNotFound
âœ… GroupDeleted
âŒ Just InternalServerError

â¤ Some things donâ€™t require custom errors (e.g., invalid data types handled by the language).

ğŸ”¸ 5. HTTP Endpoint Structure
POST /chat/groupService/v1/getAdmins
{
   "groupId": "123"
}
â¤ Use versioning in routes (v1, v2, etc.)
â¤ POST is valid here for request payload.
â¤ GET could also be used: /admins?groupId=123

ğŸ”¸ 6. GET vs POST
â¤ GET is stateless, no payload, and used for retrieval.
â¤ POST allows payload, used for complex queries or data modification.
â¤ Avoid mixing action in payload (e.g., "action": "getAdmins").

ğŸ”¸ 7. Avoiding Side Effects
âŒ Bad Practice:
â¤ setAdmins(groupId, admins) â†’ creates group if it doesn't exist AND adds users.
â¤ Doing everything in one function. 

âœ… Good Practice:
â¤ Separate APIs:
1. createGroup
2. addMembers
3. â¤ setAdmins

Why?
â¤ Prevents unexpected behavior.
â¤ Makes APIs testable, atomic, and predictable.

ğŸ”¸ 8. Atomicity in API
â¤ Atomicity = All or nothing operations.

Example:
1. setAdmins should not silently fail if group doesnâ€™t exist.
2. Instead, return an error: GroupNotFound.

ğŸ”¸ 9. Pagination & Fragmentation
ğŸ§¾ Pagination:
â¤ Break large responses (e.g., 200 users) into chunks.
â¤ Use offset and limit parameters.
GET /members?offset=0&limit=10

ğŸ§© Fragmentation:
â¤ Useful for inter-service communication with size limits.
â¤ Break response into parts and send sequentially (e.g., using TCP IDs).

ğŸ”¸ 10. Data Consistency
ğŸ“‰ Scenario:
â¤ Read request in progress â†’ admin added in DB â†’ inconsistent read.

ğŸ‘€ Should you care?
â¤ Depends on API use case:
1. For chat history: Not much
2. For financial data: Yes

ğŸ” Cache Usage:
â¤ Reduce DB load by caching
â¤ Accept slight staleness if consistency is not critical
â¤ Use graceful degradation: Send minimal info when overloaded.

ğŸ”¸ 11. Final Checklist for Designing a Good API
| Aspect               | Good Practice                                     |
| -------------------- | ------------------------------------------------- |
| API Naming           | Precise, Action-Based                             |
| Parameters           | Keep minimal and meaningful                       |
| Response             | Return only whatâ€™s needed                         |
| Error Handling       | Define expected errors clearly                    |
| Versioning           | Add versions in endpoints                         |
| GET vs POST          | Use GET for read, POST for write/complex payloads |
| Avoid Side Effects   | Split logic into atomic functions                 |
| Support Pagination   | For large responses                               |
| Ensure Atomicity     | Fail gracefully with proper messages              |
| Optimize Consistency | Based on use case & performance needs             |
| Support Caching      | To reduce repeated DB loads                       |
