üß†Pub/Sub Architecture

‚úÖ Problem with Request-Response in Microservices
Scenario:
‚û§ Services S1,S0,S2,S3,S4
‚û§ Client -> S1 (makes request)
‚û§ S1 needs to notify S0 and S2 ( order doesn't matter)
‚û§ S2 then notifies S3 and S4 (again, order doesn't matter)

Request-Response Flow:
‚û§ S1 asynchronously calls S0 and S2
‚û§ S2 then calls S3 and S4
‚û§ Problem: If S4 fails, timeout propagates -> client gets a failed response, even if most of the request was successful.

Issues:
‚û§ Coupling: S1 must know and wait for S0 and S2
‚û§ Failure Propagation: One failure leads to entire request failure.
‚û§ Retry Complications: Replaying the request can cause duplicate processing or inconsistent data.

üîÑ Pub/Sub Model (Event-Driven Architecture)
Concept:
‚û§ Replace direct communication between services with events.
‚û§ Services publish events to a Message Broker(e.g. Kafka, RabbitMQ).
‚û§ Subscribers (other services) consume those events asynchronously.

‚úÖ Revised Flow Using Pub/Sub
Client ‚Üí S1 ‚Üí Message Broker
                   ‚Üì
              S0 and S2 (subscribers)
                        ‚Üì
                 Message Broker ‚Üí S3, S4

üì¶ Advantages of Pub/Sub Architecture
1. Decoupling
‚û§ S1 doesn't need to know who consumes its message.
‚û§ Reduces service-to-service dependencies.

2. Fire-and-Forget
‚û§ Once S1 publishes to the broker, it's done.
‚û§ Broker ensures eventual delivery even if consumers are temporarily down.

3. Resiliance
‚û§ Broker stores messages.
‚û§ When a service (like S2) is back up, it receives all missed messages.

4. Scalability
‚û§ Adding a new service (like S6) only requires subscribing to the broker.
‚û§ No changes needed in publisher (S1).

5. Simplicity in Interfaces
‚û§ All messages go through a standard broker interface.
‚û§ Services consume messages based on their needs.

6. Loose Transaction Guarantee (At-Least-Once)
‚û§ If a message is persisted to the broker, it will eventually reach its destination.

‚ùå Disadvantages of Pub/Sub Systems
1. Lack of Atomic Transactions
‚û§ No global commit across services.
‚û§ Not suitable for financial systems(e.g. fund transfers)

Example:
‚û§ Commission debited from account(S0)
‚û§ Fund transfer (S0) fails or is delayed.
‚û§ Leads to inconsistent balances.

2. No Idempotency by Default
‚û§ Messages may be replayed (at-least-once semantics).
‚û§ If S2 performs non-idempotent actions(e.g. deducting money), duplicate actions may occur.

Solution: Add request Ids to messages to ensure actions are not repeated.

3. Scale data
‚û§ Services might act onn old or duplicate events if not handled correctly.

üîÑ Comparison Summary:
| Feature                | Request-Response       | Pub/Sub (Event-Driven)    |
| ---------------------- | ---------------------- | ------------------------- |
| Coupling               | High                   | Low                       |
| Failure propagation    | High                   | Isolated by broker        |
| Retry handling         | Manual, error-prone    | Handled via broker replay |
| Consistency guarantees | Stronger (with effort) | Weaker (eventual)         |
| Transactionality       | Easier to enforce      | Hard to maintain          |
| Scalability            | Limited                | High                      |
| Use case fit           | Financial systems      | Analytics, Notifications  |

üîß Use Cases Where Pub/Sub is Ideal:
‚û§ Analytics event collection
‚û§ Notification systems
‚û§ Logging pipelines
‚û§ Social networks (e.g., Tweet distribution on Twitter)
‚û§ User activity tracking

üè¶ Use Cases Where It‚Äôs Risky:
‚û§ Banking systems
‚û§ Inventory control
‚û§ Systems that require strict ACID guarantees

üîö Conclusion:
‚û§ Pub/Sub is powerful for decoupling and scaling services in non-critical workflows.
‚û§ For critical systems, implement idempotency, request tracking, or consider orchestration/transaction managers.

