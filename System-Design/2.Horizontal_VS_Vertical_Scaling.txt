ğŸ”¹ 1. What Is System Design?
â¤ Designing a software that can serve many users reliably and effeciently.
â¤ Think beyond a single computer- design for real-world usuage, failures, scaling, and performance.

ğŸ”¹ 2. From Code to System
ğŸ§© Scenario:
â¤ You wrote an algorithm/code on your personal computer.
â¤ People want to use it -> You need to make it accessible.

âœ… Solution: Expose the code via the Internet
ğŸ”¸ API (Application Programming Interface):

â¤ Interface exposed over the internet so others can send requests and receive responses.
â¤ You no longer run code manually - your server listens and responds to requests automatically.

ğŸ”¹ 3. Self-Hosting vs Cloud Hosting
ğŸ–¥ï¸ Self-hosting on personal machine:

â¤ Setup servers and databases yourself.
â¤ Problems:
1. Power loss= service outage
2. No redundancy or fault-tolerance
3. Complex configuration for endpoints

â˜ï¸ Cloud Hosting:
â¤ Rent computation power from providers (e.g. AWS, GCP, Azure).
â¤ Cloud = A collection of remote computers( data centers) provided as a service.

Benifits of Cloud:
1. Remote access
2. Reliability
3. Scalability
4. Easy backups and recovery
5. Infrastructure management handled by the providers

ğŸ”¹ 4. Scalability
âš™ï¸ Definition:
Ability of a system to handle increased load (traffic, users, data).

ğŸ”¹ 5. Vertical vs Horizontal Scaling
| Feature           | Vertical Scaling        | Horizontal Scaling                 |
| ----------------- | ----------------------- | ---------------------------------- |
| Scale Method      | Bigger machine          | More machines                      |
| Load Balancing    | Not required            | Required                           |
| Failure Tolerance | Single Point of Failure | Resilient                          |
| Communication     | Interprocess (Fast)     | Network (Slow)                     |
| Data Consistency  | Easy to maintain        | Hard to ensure                     |
| Cost Efficiency   | Expensive after a limit | Scales cost-effectively            |
| Growth Limitation | Hardware limit          | Near-infinite (with orchestration) |

ğŸ”¹ 7. Hybrid Approach
â¤ Real-world systems combine both:
â¤ Use powerful servers (vertical) in a distributed setup (horizontal).

For example, deploy large servers in a horizontally scaled architecture.

ğŸ“Œ Strategy:
â¤ Start with vertical scaling (cheaper for small systems).
â¤ When traffic grows â†’ switch to horizontal for high availability and fault tolerance.