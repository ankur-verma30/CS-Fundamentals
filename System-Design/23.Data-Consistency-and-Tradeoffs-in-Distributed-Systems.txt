ğŸ” What is Consistency?
â¤ Consistency = multiple copies of the same data must match
â¤ If data item `C` exists at multiple locations, all replicas should reflect the same value
â¤ Appears in:
    âœ”ï¸ CAP Theorem â†’ C = Consistency
    âœ”ï¸ Transactions (ACID) â†’ C = Consistency


ğŸ” Simplest Case: Single-Node System
âœ… Example: Early Facebook (Single Server at Harvard)
â¤ One server
â¤ One copy of data
â¤ All users connect to this server

ğŸ”„ Properties
â¤ Reads always return latest data
â¤ No ambiguity â†’ strong consistency

ğŸ”„ Problems
âŒ Single Point of Failure (power loss, crash, network outage)
âŒ Vertical Scaling Limit (hardware ceiling, supercomputer cost)
âŒ High Latency for global users (Oxford â†’ Harvard â‰ˆ 100ms)


ğŸ” First Attempt at Scaling: Data Splitting
ğŸ”„ Regional Servers (Harvard + Oxford)
â¤ Each server stores local campus data only
â¤ No communication between servers

ğŸ”„ Benefits
âœ… Reduced latency for local users
âœ… Reduced load per server

ğŸ”„ Problems
âŒ No data sharing â†’ breaks core Facebook use case
âŒ Still single point of failure per region
âŒ Cross-region reads still expensive


ğŸ” Adding Caching
ğŸ”„ Idea
â¤ Cache popular Oxford profiles in Harvard server

ğŸ”„ Flow
â¤ Cache miss â†’ fetch from Oxford
â¤ Store locally â†’ future reads are fast

ğŸ”„ Limitations
âŒ Cache misses still slow
âŒ Cache eviction causes latency spikes
âŒ Cache does NOT solve write consistency


ğŸ” Replication: Multiple Copies of Data
ğŸ”„ Key Idea
â¤ Store same data in multiple regions (US + Europe)

ğŸ”„ Benefits
âœ… No single point of failure
âœ… Low read latency (local reads)
âœ… Better availability


ğŸ”„ New Problem Introduced
ğŸš¨ Consistency- How do updates propagate reliably?


ğŸ” Update Propagation Problem
ğŸ”„ Scenario
â¤ US updates `C â†’ C++`
â¤ Europe must reflect same update

ğŸ”„ Naive Approach
â¤ Send update via network (TCP)
â¤ Wait for acknowledgement

ğŸ”„ Failure Scenarios
â¤ Network drops message
â¤ Server crashes
â¤ Acknowledgement lost


ğŸ” Two Generals Problem (Core Theory)
â¤ Impossible to guarantee agreement using acknowledgements over unreliable networks
â¤ Infinite ACK-of-ACK chain
â¤ You can never be 100% sure both sides committed
ğŸ‘‰ Perfect coordination is impossible in unreliable distributed systems


ğŸ” Leaderâ€“Follower Model
ğŸ”„ Idea
â¤ Assign one node as Leader
â¤ Only leader accepts writes
â¤ Followers replicate leader state

ğŸ”„ Pros
â¤ Simplifies write path
â¤ Avoids write conflicts

ğŸ”„ Remaining Problem
â¤ If follower lags â†’ stale reads
â¤ If reads block â†’ system unavailable


ğŸ” Consistency vs Availability Trade-off
â¤ If you:
  âœ”ï¸ Wait for all replicas â†’ consistent but unavailable
  âœ”ï¸ Respond early â†’ available but inconsistent
ğŸ‘‰ This is the CAP trade-off in practice


ğŸ” Two-Phase Commit (2PC)
ğŸ”„ Used When
â¤ Absolute consistency required
â¤ Financial systems, banking, ledgers

ğŸ”„ Actors
â¤ Leader (Coordinator)
â¤ Multiple Followers (Participants)


ğŸ” Phase 1: Prepare
â¤ Leader sends PREPARE to followers
â¤ Followers:
    âœ”ï¸ Begin transaction
    âœ”ï¸ Apply changes locally
    âœ”ï¸ DO NOT commit
    âœ”ï¸ Reply READY / ABORT


ğŸ” Phase 2: Commit
â¤ If all followers reply READY:
    âœ”ï¸ Leader commits locally
    âœ”ï¸ Sends COMMIT to followers
â¤ Followers commit transaction


ğŸ” Failure Handling in 2PC
ğŸ”„ If PREPARE fails
â¤ Leader sends ROLLBACK
â¤ Followers revert changes

ğŸ”„ If COMMIT message lost
â¤ Leader retries commit
â¤ Uses transaction IDs (idempotency)


ğŸ” Blocking Problem in 2PC
â¤ Followers cannot decide independently
â¤ Must wait for leader decision
â¤ If leader crashes â†’ followers block

ğŸ‘‰ System becomes:
 âœ… Consistent
 âŒ Not Available


ğŸ” Read & Write Blocking
â¤ During commit:
 âœ”ï¸ Reads blocked
 âœ”ï¸ Writes blocked
â¤ Ensures strong consistency
â¤ Destroys availability


ğŸ” Cost of Strong Consistency
â¤ High latency
â¤ Low throughput
â¤ Blocking behavior
â¤ Higher infrastructure cost


ğŸ” Eventual Consistency
System becomes consistent eventually, not immediately
ğŸ”„ Properties
â¤ Fast writes
â¤ High availability
â¤ Temporary inconsistencies allowed


ğŸ”„ Used In
â¤ Facebook feeds
â¤ Likes, comments
â¤ Shopping carts
â¤ Analytics


ğŸ” Real-World Mapping
â¤ 2PC â†’ Banking transactions
â¤ Leader-Follower â†’ MySQL replication
â¤ Eventual Consistency â†’ DynamoDB, Cassandra


ğŸ” Key Takeaway
Consistency is not free. Every extra guarantee costs latency, availability, or money.
