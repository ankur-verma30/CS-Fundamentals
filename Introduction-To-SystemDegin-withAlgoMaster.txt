============================
ğŸ”· What Is System Design?
============================
â¤ At its core, System Design is the process of defining how different parts of a software system interact to meet both functional (what it should do) and non-functional (how well it should do it) requirements.
â¤ Itâ€™s not about writing code, at least not yet. Itâ€™s about making high-level architectural decisions that balance scalability, reliability, performance, and cost.


ğŸ”„ Real-World Analogy: Designing a Skyscraper
â¤ Imagine youâ€™re an architect designing a skyscraper.
â¤ You donâ€™t start by laying bricks. You start by asking questions:

â“ How many floors will it have?
â“ How many people should it support?
â“ What kind of soil is it built on?
â“ What level of earthquake resistance is needed?

âœ”ï¸ Once the requirements are clear, you create blueprints showing how everything fits together: the foundation, the structural supports, the plumbing, the electrical layout, and the elevator shafts.
âœ”ï¸ You also consider how different systems interact, such as how plumbing might affect electrical layouts.
âœ”ï¸ You plan for future expansion (scalability) and think about how the building will handle unexpected issues (fault tolerance).


ğŸ‘‰ In the software world, this translates to:
â¤ Architecture â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The overall structure of the system. Should the system be built as a monolith, a set of microservices, or an event-driven system?
â¤ Components/Modules â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Databases, servers, load balancers, caches, message queues, and APIs.
â¤ Interfaces â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ How these components communicate with each other
(e.g., REST APIs, gRPC).
â¤ Data â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ How data is stored, managed, accessed, and kept consistent.


======================================
ğŸ”· 10 Big Questions of System Design
======================================
On a high level, system design revolves around answering these 10 big questions:

1ï¸âƒ£ Scalability â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ How will the system handle a large number of users or requests simultaneously?
2ï¸âƒ£ Latency and Performance â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ How can we reduce response time and ensure low-latency performance under load?
3ï¸âƒ£ Communication â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ How do different components of the system interact with each other?
4ï¸âƒ£ Data Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ How should we store, retrieve, and manage data efficiently?
5ï¸âƒ£ Fault Tolerance and Reliability â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ What happens if a part of the system crashes or becomes unreachable?
6ï¸âƒ£ Security â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ How do we protect the system against threats such as unauthorized access, data breaches, or denial-of-service attacks?
7ï¸âƒ£ Maintainability and Extensibility â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ How easy is it to maintain, monitor, debug, and evolve the system over time?
8ï¸âƒ£ Cost Efficiency â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ How can we balance performance with infrastructure cost?
9ï¸âƒ£ Observability and Monitoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ How do we monitor system health and diagnose issues in production?
1ï¸âƒ£0ï¸âƒ£ Compliance and Privacy â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Are we complying with relevant laws and regulations (e.g., GDPR, HIPAA)?


============================
ğŸ”· Key Components of System
=============================
A typical software system can be broken down into several key components:

1ï¸âƒ£ Client/Frontend â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The part of the system that users interact with directly (e.g., web browsers, mobile apps). It is responsible for displaying information, collecting user input, and communicating with the backend.

2ï¸âƒ£ Server/Backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The backend handles the core functionality of the system. It processes incoming requests, executes business logic, interacts with databases or services, and sends responses back to the client.

3ï¸âƒ£ Database/Storage â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ This component is responsible for storing and managing data. It can take various forms, including relational databases (SQL), non-relational stores (NoSQL), in-memory caches, or distributed object storage systems, depending on the needs of the application.

4ï¸âƒ£ Networking Layer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ This includes components like load balancers, APIs, and communication protocols that ensure reliable and efficient interaction between different parts of the system.

5ï¸âƒ£ Third-party Services â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ These are external APIs or platforms that extend the systemâ€™s capabilities. Common examples include payment processors, email or SMS notification services, authentication providers, analytics tools, and cloud-based AI services.


============================
ğŸ”· Process of System Design
=============================
Designing a system is not a one-size-fits-all approach. Itâ€™s a step-by-step process that starts with understanding the requirements and ends with a detailed blueprint.

Here are the key steps:
Step 1ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Requirements Gathering
Every design starts with a conversation. Before drawing diagrams or choosing technologies, focus on understanding what the system needs to do.

Ask questions like:
â“ What are the functional requirements (core features and workflows)?
â“ What are the non-functional requirements (scalability, availability, latency, consistency)?
â“ Who are the users, and how many are expected initially and at scale?
â“ Whatâ€™s the expected data volume and traffic pattern?
â“ Are there any constraints (e.g., specific technologies, budgets, or compliance rules)


Step 2ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Back-of-the-Envelope Estimation
Next, estimate the scale of your system. Approximate numbers give you a sense of what youâ€™re designing for.

Estimate:
âœ”ï¸ Data size (storage requirements)
âœ”ï¸ Queries per second (QPS) or requests per second (RPS)
âœ”ï¸ Bandwidth needs
âœ”ï¸ Number of servers or instances required

ğŸ‘‰ These rough calculations help guide architectural decisions and ensure your design is grounded in realistic expectations.


Step 3ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ High-Level Design (HLD)
Now that you understand what youâ€™re building and how big it needs to be, start visualizing the systemâ€™s core components and how they interact.

Define:
âœ”ï¸ The main modules and services
âœ”ï¸ Data flow between them
âœ”ï¸ External dependencies (e.g., third-party APIs, external databases)

ğŸ‘‰ At this stage, youâ€™re sketching the architecture blueprint, a birdâ€™s-eye view of the system.


Step 4ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Data Model / API Design
Once the architecture is clear, move closer to the data and interfaces.

âœ”ï¸ Choose the right database type(s) â€” relational, NoSQL, time-series, etc.
âœ”ï¸ Define schemas, tables, and relationships to support your use cases.
âœ”ï¸ Design APIs for interaction between services (e.g., POST /tweet, GET /timeline).


Step 5ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Detailed Design / Deep Dive
Zoom into each component and define:
âœ”ï¸ Internal logic, caching, and concurrency handling
âœ”ï¸ Scaling strategies (horizontal vs vertical scaling)
âœ”ï¸ Replication, partitioning, and fault tolerance

This is also where you address non-functional requirements (NFRs) like availability, reliability, and latency.
ğŸ‘‰ In other words, you go from what the system does to how it does it.


Step 6ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Identify Bottlenecks and Trade-offs
No system is perfect. Every choice has trade-offs.

Ask yourself:
â“ Where could the system break under high load?
â“ What are the single points of failure?
â“ Can caching or replication help reduce pressure?
â“ Is it okay to choose eventual consistency for higher availability?

ğŸ‘‰ A strong design doesnâ€™t eliminate trade-offs, it makes them explicit and justifiable.


Step 7ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Review, Explain, and Iterate
âœ”ï¸ Finally, step back and evaluate. Explain your design decisions clearlyâ€”why you made certain choices and how they meet the requirements.
âœ”ï¸ Be open to feedback, iterate on weak spots, and refine your design.
âœ”ï¸ You donâ€™t need to get everything perfect on the first try. What matters is your ability to adapt, refine, and evolve the design as you uncover new insights or constraints.


===========================
ğŸ”· System Design Concepts
===========================
1ï¸âƒ£ Networking Foundations â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ How computers talk to each other
2ï¸âƒ£ APIs and Communication â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ How applications exchange data
3ï¸âƒ£ Data Storage â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Where and how data lives
4ï¸âƒ£ Scaling â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Handling growth
5ï¸âƒ£ Distributed Systems â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Challenges of running multiple machines
6ï¸âƒ£ Architecture Patterns â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Organizing large-scale systems


===========================
ğŸ”· Networking Foundations
===========================
Before designing any system, you need to understand how computers talk to each other. Every single request in a distributed system, whether it is a Google search or an Instagram like, travels across a network.

These six concepts are the foundation everything else rests on.
1ï¸âƒ£ Client-Server Model
â¤ Every web application you use follows a simple pattern: your browser (the client) asks a server for something, and the server responds.
â¤ That is the client-server model. It is so fundamental that you will see it in literally every system design diagram.

+------------------+           Request            +----------------------+
|                  | --------------------------> |                      |
|      CLIENT      |                             |        SERVER        |
|  (Browser / App) | <-------------------------- |  (API / Backend)     |
|                  |           Response          |                      |
+------------------+                             +----------+-----------+
                                                             |
                                                             |
                                                             v
                                                   +----------------------+
                                                   |                      |
                                                   |      DATABASE        |
                                                   |   (MySQL / NoSQL)    |
                                                   |                      |
                                                   +----------------------+

â¤ The client is any device that initiates a request: your browser, a mobile app, or even another server.
â¤ The server listens for requests, processes them, and sends back responses.
â¤ This separation is powerful because it lets you change the client (build a mobile app alongside the web app) without touching the server, and scale the server independently of clients.

â“ But how does the client actually find the server on the internet?


2ï¸âƒ£ IP(Internet Protocol) Address
â¤ Every device connected to the internet has a unique address, just like every house has a street address.
â¤ That is an IP address. Without it, your request would have no idea where to go.

+------------------+   Packet   +------------------+   Routes to  +------------------+   Delivers to +------------------+
|   Your Device    | --------> |      Router      | ------------> |     Internet     | -------------> |      Server      |
| 192.168.1.10     |           |    Gateway       |               |    Backbone      |                | 142.250.80.46    |
+------------------+           +------------------+               +------------------+                +------------------+

There are two versions:
    âœ”ï¸ IPv4 (like 192.168.1.1) and IPv6 (like 2001:0db8:85a3::8a2e:0370:7334).
    âœ”ï¸ IPv4 gives us about 4.3 billion addresses, which seemed like plenty until every smartphone, laptop, and smart fridge needed one.
    âœ”ï¸ IPv6 solves this by offering a virtually unlimited number of addresses.

â¤ For system design, the key thing to know is that IP addresses identify machines on a network.
â¤ When you talk about servers, load balancers, or database nodes, each one has an IP address that others use to reach it.


â“ Of course, nobody wants to memorize IP addresses. So how does your browser know that "google.com" maps to 142.250.80.46?


3ï¸âƒ£ DNS (Domain Name System)
â¤ DNS is the phone book of the internet. You type "google.com" into your browser, and DNS translates that into an IP address your computer can actually route to.
â¤ Without DNS, you would need to memorize the IP address of every website you visit.


+------------------+   Query / Ask   +---------------------+   Try   +--------------+   Try .com   +------------------+   Try google   +-----------------------+   IP Address   +------------------+
|     Browser      | --------------> |    DNS Resolver     | ------> |  Root Server  | ----------> |   TLD Server     | ------------> |  Authoritative NS     | ------------> |  IP: 142.250.80.46 |
|   google.com     |                 |     ISP / Local     |         |               |             |      .com        |               |                       |               |                    |
+------------------+                 +---------------------+         +--------------+             +------------------+               +-----------------------+               +------------------+


â¤ The resolution process involves multiple servers working together.
â¤ Your browser first checks its local cache. If the answer is not there, it asks a DNS resolver (usually provided by your ISP).
â¤ The resolver queries root servers, then top-level domain servers (.com, .org), and finally the authoritative name server for that specific domain.
â¤ The result gets cached at every level so this chain does not repeat for every request.

â¤ DNS is also used for load balancing (returning different IPs for the same domain) and failover (pointing traffic to a backup server when the primary goes down).

ğŸ‘‰ Now that the client can find the server, your request doesn't always go directly to the server.


4ï¸âƒ£ Proxy vs Reverse Proxy
ğŸ”„ Forword Proxy
+-----------+     Request     +----------------+     Request     +----------------+
|  Client   |  ------------> |  Forward Proxy |  ------------> |  Internet /    |
| (User)    |                |                |                |  Server        |
+-----------+                +----------------+                +----------------+
      ^                             |
      |         Response            |
      +-----------------------------+

A forward proxy sits in front of clients. It hides the client's identity from the server.
Think of a VPN or corporate proxy: the server sees the proxy's IP, not yours. Use cases include privacy, content filtering, and bypassing geo-restrictions.


ğŸ”„ Reverse Proxy
+-----------+     Request     +----------------+     Request     +------------------+
|  Client   |  ------------> | Reverse Proxy  |  ------------> |  Backend Server  |
| (User)    |                |                |                |  (App Servers)   |
+-----------+                +----------------+                +------------------+
      ^                             |
      |         Response            |
      +-----------------------------+

â¤ A reverse proxy sits in front of servers. It hides the server's identity from the client.
â¤ The client thinks it is talking to one server, but the reverse proxy could be routing requests to dozens of backend servers.
â¤ Nginx and HAProxy are common examples. Reverse proxies handle SSL termination, caching, compression, and load balancing.


ğŸ‘‰ Whenever a client communicates with a server, thereâ€™s always some delay. One of the biggest causes of this delay is physical distance and that's latency.


5ï¸âƒ£ Latency and Bandwidth
â¤ Latency is the time it takes for data to travel from point A to point B. It is measured in milliseconds and it directly impacts user experience.
â¤ A 100ms delay is barely noticeable, but 1 second feels sluggish, and 3 seconds? Users start leaving.


+-----------+   Transmission Delay   +-----------+   Propagation Delay   +-----------+   Processing Delay   +-----------+   Queuing Delay   +-----------+
|  Client   | --------------------> |  Network  | --------------------> |  Router   | ------------------> |  Router   | ----------------> |  Server   |
+-----------+                       +-----------+                       +-----------+                     +-----------+                   +-----------+

â¤ Latency comes from multiple sources: network distance (speed of light in fiber), serialization (converting data to bytes), processing time on the server, and queuing delays when the server is busy.
â¤ You cannot beat physics, so a request from Mumbai to New York will always take longer than Mumbai to a nearby server.
â¤ This is why system design solutions often include CDNs (serving content from nearby edge nodes), caching (avoiding round trips to the database), and regional deployments (placing servers closer to users).

ğŸ‘‰ Reducing latency is one of the most common non-functional requirements in system design.

Now, when data actually travels between client and server, what language do they speak?


6ï¸âƒ£ Protocols: HTTP/ HTTPS
â¤ HTTP (Hypertext Transfer Protocol) is the language that clients and servers use to communicate on the web.
â¤ It defines how requests are structured and how responses come back.
â¤ HTTPS is the same thing, but encrypted with TLS so nobody can eavesdrop.


+-----------+   Client Hello    +-----------+
|  Browser  | ----------------> |  Server   |
| (Client)  |                   |           |
+-----------+                   +-----------+
       |                               |
       |   Server Hello + Certificate |
       | <----------------------------|
       |                              |
       |  Certificate Verification    |
       |  (CA / Trust Store)          |
       |                              |
       |  Pre-Master Secret           |
       |  (Encrypted with Public Key) |
       | ---------------------------->|
       |                              |
       |  Session Key Generated       |
       | <----------------------------|
       |                              |
       |====== Secure TLS Tunnel ====>|
       |                              |
       |  HTTPS GET Request           |
       |  (Encrypted HTTP Header)     |
       | ---------------------------->|
       |                              |
       |  HTTPS Response (Data)       |
       | <----------------------------|
       |                              |
       |  HTTPS POST Request          |
       |  (Encrypted Header + Body)   |
       | ---------------------------->|
       |                              |
       |  HTTPS Response (Status/Data)|
       | <----------------------------|
       |                              |

â¤ HTTP is stateless: each request is independent, and the server does not remember previous requests.
â¤ This makes scaling easier (any server can handle any request) but means you need mechanisms like cookies, tokens, or sessions to maintain state across requests.

â“ Key things to know for interviews: HTTP methods (GET, POST, PUT, DELETE), status codes (200 OK, 404 Not Found, 500 Server Error), and headers (for authentication, caching, content type).
â¤ HTTPS adds a TLS handshake that takes an extra round trip but protects data in transit.

ğŸ‘‰ With networking covered, let's move up a layer. How do applications actually exchange data in a structured way?


===========================
ğŸ”· APIs and Communication
===========================
Now that we know how machines connect, how do applications actually talk to each other? You need well-defined contracts, called APIs, that specify what data you can request and what format it comes back in.

This group covers the major API styles and real-time communication patterns.
1ï¸âƒ£  APIs (Application Programming Interfaces)
An API is a contract between two pieces of software. It defines what you can ask for, how to ask for it, and what you will get back.

+-------------+   JSON Request   +-------------+   Route to   +---------------------------+   Process   +------------------+
|  Client App | --------------> |  API Layer  | -----------> | Authentication & Validation | ---------> |  Business Logic  |
+-------------+                 | Endpoints   |              +---------------------------+            +------------------+
       ^                         +-------------+                                                          |
       |                                                                                                    |
       |--------------------------------------- JSON Response ---------------------------------------------+


ğŸŸ¢ Real-World Analogy:
Think of an API like a restaurant menu. You do not go into the kitchen and cook. You look at the menu (API documentation), place an order (request), and get your food (response). The kitchen (server) handles the complexity behind the scenes.

â¤ Most modern APIs communicate using JSON over HTTP.
â¤ The client sends a request to a specific URL (called an endpoint), the server processes it, and returns a response with a status code and data.
â¤ But, not all APIs are built the same. Different API styles exist to serve different needs. Two of the most popular ones are REST and GraphQL.


2ï¸âƒ£ REST (Representational State Transfer)
â¤ REST (Representational State Transfer) is the most common API style on the web.
â¤ It treats everything as a "resource" and uses standard HTTP methods to interact with those resources.
â¤ It is simple, stateless, and works well for most applications.

+-------------+   HTTP Request   +------------------+   Route to   +-------------------------+   Execute   +------------------+
|  Client App | --------------> |   REST API       | -----------> | Authentication &        | ---------> |  Business Logic  |
| (Web/Mobile)|                 |   Controller     |              | Authorization &         |            |  (Service Layer) |
+-------------+                 +------------------+              | Validation              |            +------------------+
       ^                                                                            |
       |                                                                            |
       |-------------------------------------- HTTP Response (JSON/XML) -----------+

â¤ REST maps naturally to CRUD operations: Create (POST), Read (GET), Update (PUT/PATCH), and Delete (DELETE).
â¤ Each resource gets its own URL, and the HTTP method tells the server what to do.
âœ… For example, GET /users/123 fetches user 123, while DELETE /users/123 removes them.

Key REST principles:
    âœ”ï¸ stateless (no session on the server)
    âœ”ï¸ cacheable (responses can be cached)
    âœ”ï¸ uniform interface (consistent URL patterns)
REST's simplicity is its biggest strength, but it has a drawback: if a client needs data from multiple resources, it has to make multiple requests.

â“ What if the client could get exactly the data it needs in a single request?


3ï¸âƒ£ GraphQL
GraphQL, developed by Facebook, lets clients request exactly the data they need in one query.
Instead of hitting multiple REST endpoints, you send a single query describing the shape of the data you want, and the server returns exactly that.

+-------------+   GraphQL Query   +------------------+   Parse & Validate   +------------------+   Fetch Data   +------------------+
|  Client App | ----------------> |  GraphQL Server  | -------------------> |     Schema       | ------------> |    Resolvers     |
| (UI / App)  |                  |   (Single API)   |                      | (Type System)   |               | (Business Logic)|
+-------------+                  +------------------+                      +------------------+               +------------------+
       ^                                                                                                             |
       |                                                                                                             |
       |--------------------------------------------- GraphQL Response ---------------------------------------------+

â¤ With REST, fetching a user's profile with their posts might require two separate requests: one to /users/123 and another to /users/123/posts.
â¤ With GraphQL, you describe both in a single query, and the server resolves them and returns a combined result.

â¤ The trade-off? GraphQL adds complexity on the server side (you need resolvers for each field), can make caching harder (since every query is different), and can lead to performance issues if clients request deeply nested data.

â¤ For most system design problems, REST is the safer default, but mentioning GraphQL shows breadth of knowledge, especially for systems where clients need flexible data fetching (like social media feeds).

REST and GraphQL handle request-response patterns. But what about real-time communication where the server needs to push data to clients?


4ï¸âƒ£ WebSockets
HTTP is a one-way street: the client always initiates the request. But what about chat apps, live sports scores, or collaborative editors?

You need the server to push updates to the client instantly. That is where WebSockets come in.

CLIENT SIDE                                  SERVER SIDE
-----------                                  -----------
+----------------------+                     +----------------------+
|        Client        |                     |        Server        |
|   (Browser / App)    |                     |  (WebSocket Server) |
+----------+-----------+                     +----------+-----------+
           |                                            |
           |  HTTP Upgrade Request                      |
           |  (Handshake)                               |
           |------------------------------------------->|
           |                                            |
           |  101 Switching Protocols                   |
           |  (Upgrade to WebSocket)                    |
           |<-------------------------------------------|
           |                                            |
+----------+-----------+                     +----------+-----------+
|  WebSocket Connection |<==================>|  WebSocket Connection |
|   (Persistent)        |   Full-Duplex      |   (Persistent)        |
+----------+-----------+                     +----------+-----------+
           |                                            |
           |  Message Frame (Text / Binary)             |
           |------------------------------------------->|
           |                                            |
           |  Message Frame (Text / Binary)             |
           |<-------------------------------------------|
           |                                            |
+----------+-----------+                     +----------+-----------+
| Application Logic     |                     | Application Logic     |
| (Chat / Notifications)|                     | (Broadcast / Process) |
+----------------------+                     +----------------------+

â¤ WebSockets start as a regular HTTP request, then "upgrade" to a persistent, bidirectional connection.
â¤ Once established, both sides can send messages at any time without the overhead of creating new HTTP connections.
â¤ This makes them perfect for real-time features.

â¤ The downside is that WebSocket connections are stateful, the server needs to keep track of every open connection, which makes scaling harder.
â¤ If a server goes down, all its connections are lost.

â¤ WebSockets enable real-time communication between a client and a server, but what if a server needs to notify another server (or client) when an event occurs?

âœ… Example:
When a user makes a payment, Stripe needs to notify your application instantly.
If someone pushes code to GitHub, a CI/CD system (e.g., Jenkins) should be triggered automatically.
This is where Webhooks come in.


5ï¸âƒ£ Webhooks
â¤ Webhooks flip the usual model around. Instead of the client repeatedly asking "has anything changed?" (polling), the server sends a notification to the client when something happens.
â¤ The client registers a callback URL, and the server POSTs to that URL whenever the event occurs.

EVENT SOURCE / SENDER                     RECEIVER / LISTENER
----------------------                    ----------------------
+----------------------+                  +----------------------+
|   Source Application |                  |   Receiver Server    |
|  (GitHub / Stripe)   |                  |   (Webhook Endpoint) |
+----------+-----------+                  +----------+-----------+
           |                                           |
           |  Event Occurs                             |
           |  (Push, Payment, Commit)                  |
           |------------------------------------------>|
           |                                           |
+----------+-----------+                               |
|  Webhook Configured  |                               |
|  (Callback URL)      |                               |
+----------+-----------+                               |
           |                                           |
           |  HTTP POST Request                        |
           |  (JSON Payload + Signature)               |
           |------------------------------------------>|
           |                                           |
                                                +------+-----------+
                                                |  Authentication / |
                                                |  Signature Verify |
                                                +------+-----------+
                                                       |
                                                +------+-----------+
                                                |   Business Logic |
                                                |  (Process Event) |
                                                +------+-----------+
                                                       |
                                                +------+-----------+
                                                |   Response (2xx) |
                                                |   Acknowledgment |
                                                +------------------+

â¤ Webhooks are widely used for integrations: payment notifications (Stripe), code push events (GitHub), message delivery status (Twilio).
â¤ The key challenge is reliability, what if your server is down when the webhook fires? Good webhook systems include retry logic, event logging, and idempotency handling.
â¤ In system design, use webhooks for asynchronous event notifications between services, especially when integrating with third-party platforms.

â“ We have covered how data moves between applications. But where does all that data actually live?


===========================
ğŸ”· Data Storage
===========================
APIs move data around, but where does that data actually live? Choosing the right storage strategy is one of the most important decisions in system design. This group covers database types, indexing, partitioning, caching, and more.

1ï¸âƒ£ Databases
â¤ A database is an organized collection of data that supports efficient storage, retrieval, and manipulation.
â¤ But there is no single "best" database. Different data shapes and access patterns call for different types.

                                  +----------------------+
                                  |       DATABASE       |
                                  +----------+-----------+
                                             |
        --------------------------------------------------------------------------------
        |                                 |                                   |
+---------------------+         +---------------------+              +----------------------+
|   Relational DB     |         |    NoSQL DB         |              |   Specialized DB     |
|   (SQL Databases)   |         |  (Non-Relational)   |              |                      |
+----------+----------+         +----------+----------+              +----------+-----------+
           |                               |                                      |
    +------+-------+        ---------------------------------          ------------------------
    |              |        |        |        |        |                |          |          |
+-------+     +---------+ +--------+ +--------+ +--------+ +--------+ +---------+ +--------+
| Tables|     | Schema  | | Key-    | | Document| | Column | | Graph  | | In-Memory| | Time   |
| Rows  |     | Fixed   | | Value   | | Store   | | Store  | | DB     | | DB       | | Series |
+-------+     +---------+ +--------+ +--------+ +--------+ +--------+ +---------+ +--------+
                                  |
                         -------------------------
                         |          |            |
                   +----------+ +----------+ +----------+
                   | MongoDB  | | Cassandra| | Redis    |
                   +----------+ +----------+ +----------+


âœ”ï¸ Relational databases â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ (PostgreSQL, MySQL) store data in structured tables with defined relationships. Great for transactional data where consistency matters.

âœ”ï¸ Document databases â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ (MongoDB) store data as flexible JSON-like documents. Good for varied or evolving schemas.

âœ”ï¸ Key-value â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ stores (Redis, DynamoDB) are like hash maps, blazing fast for simple lookups by key.

âœ”ï¸ Graph databases â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ (Neo4j) model relationships as first-class citizens, ideal for social networks or recommendation engines.

â¤ In system design, we choose database based on the data model, query patterns, and scalability requirements.
â¤ There is no right answer without context.

The most common choice is between relational and non-relational databases. Let's dig deeper into that decision.


2ï¸âƒ£ SQL vs NoSQL
â¤ SQL databases enforce a strict schema and support ACID transactions.
â¤ NoSQL databases trade some of that rigidity for flexibility and horizontal scalability.

                           +----------------------+
                           |       DATABASE       |
                           +----------+-----------+
                                      |
                    -----------------------------------------
                    |                                       |
          +----------------------+              +----------------------+
          |      SQL Databases   |              |    NoSQL Databases   |
          |   (Relational DB)    |              |  (Non-Relational)   |
          +----------+-----------+              +----------+-----------+
                     |                                      |
          ---------------------------           ------------------------------------
          |           |             |           |        |        |              |
+----------------+ +----------------+ +----------------+ +-----------+ +-----------+ +-----------+
|   Structured   | | Fixed Schema   | |   ACID Model   | | Key-Value | | Document  | | Column /  |
|   Tables       | | (Predefined)   | | Transactions   | | Store     | | Store     | | Graph DB  |
+----------------+ +----------------+ +----------------+ +-----------+ +-----------+ +-----------+
                     |                                      |
               +-------------+                     +-------------------------+
               |  Examples   |                     |        Examples         |
               |  MySQL      |                     |  MongoDB, Redis         |
               |  PostgreSQL |                     +-------------------------+
               +-------------+


Choose SQL when â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ You need strong consistency (banking, inventory), complex queries with joins, well-defined schemas that rarely change, or ACID guarantees.

Choose NoSQL when â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ You need horizontal scalability, your schema evolves frequently, you are dealing with high write throughput, or your data is naturally unstructured (logs, social media posts).


â¤ The reality is that most production systems use both.
â¤ An e-commerce platform might store orders in PostgreSQL (needs ACID) and product catalog in MongoDB (flexible schema, read-heavy).
â¤ The key interview insight is explaining why you chose one over the other for a specific part of your system.

â“ Once you have data in a database, how do you find it quickly?


3ï¸âƒ£ Database Indexing
â¤ Without an index, finding a row in a table means scanning every single row, one by one.
â¤ That is fine for 100 rows. For 100 million rows? That is a disaster.
â¤ An index is a data structure that makes lookups fast, like the index at the back of a textbook.

Most databases use B-tree indexes by default.
â¤ A B-tree organizes data in a sorted, balanced tree structure that supports O(log n) lookups.
â¤ When you create an index on the email column, the database builds a separate B-tree that maps email values to their row locations on disk.

The trade-off: indexes speed up reads but slow down writes (every INSERT or UPDATE must also update the index).
â¤ They also consume storage space. You should index columns that appear in WHERE clauses and JOIN conditions, but avoid indexing everything.

â“ Indexes help you find data faster, but what happens when a single database cannot hold all your data?


4ï¸âƒ£ Vertical Partitioning
When your database tables grow wide with dozens of columns, vertical partitioning splits them into narrower tables. Each partition holds a subset of columns, and they are joined by a shared key.

                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚        EMPLOYEE TABLE          â”‚
                         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
                         â”‚ emp_id | name | age | salary | â”‚
                         â”‚ address | phone | dept | DOJ | â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                   Vertical Partition â”‚ (Column-wise Split)
                                      â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚        EMP_BASIC_INFO          â”‚     â”‚      EMP_CONFIDENTIAL_INFO     â”‚
        â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
        â”‚ emp_id (PK)                    â”‚     â”‚ emp_id (PK)                    â”‚
        â”‚ name                           â”‚     â”‚ salary                         â”‚
        â”‚ age                            â”‚     â”‚ address                        â”‚
        â”‚ dept                           â”‚     â”‚ phone                          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚                                     â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ JOIN ON emp_id â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â¤ The idea is to separate data by access pattern. Your user profile page needs name and avatar, not the billing address.
â¤ By splitting the table, each query touches only the columns it actually needs, which means fewer bytes read from disk and faster responses.

â¤ Vertical partitioning also improves security (billing data can have stricter access controls) and allows each partition to be optimized independently (different indexes, different storage engines).
â¤ In interviews, mention it when you have a table with many columns that are accessed in different contexts.

â¤ Sometimes the problem is not wide tables but too many rows.
â¤ And sometimes the solution is not better querying, but smarter storage. What if you stored pre-computed results?


5ï¸âƒ£ Caching
â¤ Caching stores frequently accessed data in a fast layer (usually memory) so you do not have to hit the database for every request.
â¤ It is the single most effective technique for improving read performance.

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client     â”‚
â”‚ (Browser /   â”‚
â”‚ Mobile App)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ Request (GET /data)
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   API /      â”‚
â”‚ Application  â”‚
â”‚   Server     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 1ï¸âƒ£ Check Cache
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Cache      â”‚
â”‚ (Redis /     â”‚
â”‚ Memcached)   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ Cache Hit âœ…        Cache Miss âŒ
       â”‚                    â”‚
       â”‚                    â–¼
       â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚            â”‚  Database    â”‚
       â”‚            â”‚ (MySQL /     â”‚
       â”‚            â”‚ MongoDB)     â”‚
       â”‚            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                    â”‚
       â”‚      2ï¸âƒ£ Store Data â”‚
       â”‚         in Cache   â”‚
       â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Response     â”‚
â”‚ Sent to      â”‚
â”‚ Client       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â¤ The pattern shown above is called cache-aside (or lazy loading).
â¤ The application checks the cache first. On a hit, it returns immediately.
â¤ On a miss, it fetches from the database, stores the result in the cache, and then returns it.
â¤ Redis and Memcached are the most popular in-memory caches.

â¤ The hard part of caching is invalidation: when the underlying data changes, the cache needs to be updated or cleared.
â¤ Common strategies include TTL (time-to-live, data expires automatically), write-through (update cache and database together), and write-behind (update cache first, database later).

â“ Caching helps with read performance. But what about queries that need to join multiple tables?


6ï¸âƒ£ Denormalization
â¤ In normalized databases, data is split across many tables to avoid duplication.
â¤ That is clean, but joining 5 tables to load a single page is slow. Denormalization deliberately adds redundant data to reduce the number of joins.

          NORMALIZED DATABASE (Before)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Users Table     â”‚
â”‚ user_id (PK)         â”‚
â”‚ name                 â”‚
â”‚ email                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ JOIN
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Orders Table    â”‚
â”‚ order_id (PK)        â”‚
â”‚ user_id (FK)         â”‚
â”‚ order_date           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ JOIN
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Order_Items Table â”‚
â”‚ item_id              â”‚
â”‚ order_id (FK)        â”‚
â”‚ product_id           â”‚
â”‚ quantity             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

            âŒ Multiple JOINs
            âŒ Slower Reads
            âŒ Complex Queries

                   â†“ DENORMALIZATION â†“

        DENORMALIZED DATABASE (After)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Orders_Denormalized       â”‚
â”‚ order_id                         â”‚
â”‚ user_id                          â”‚
â”‚ user_name        â† duplicated    â”‚
â”‚ user_email       â† duplicated    â”‚
â”‚ order_date                       â”‚
â”‚ product_id                       â”‚
â”‚ quantity                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

            âœ… No JOINs
            âœ… Faster Reads
            âŒ Data Duplication



â¤ In the normalized version, displaying an order with the user's name and product title requires joining three tables.
â¤ In the denormalized version, all the data is in one table, so a single read returns everything.
â¤ The trade-off: you are storing user_name and product_title in the orders table, which means if a user changes their name, you need to update it in multiple places.

â¤ Denormalization is a read optimization.
â¤ Use it when your system is read-heavy and those reads involve expensive joins.
â¤ It is very common in NoSQL databases, where joins are not natively supported.
â¤ In interviews, always pair denormalization with a strategy for keeping the redundant data consistent.

â“ Databases handle structured data. But what about images, videos, and large files?


7ï¸âƒ£ Blob Storage
â¤ Not all data fits neatly into rows and columns.
â¤ Images, videos, PDFs, backups, these are "binary large objects" (blobs) that need specialized storage.
â¤ Blob storage systems like Amazon S3 are designed to store massive amounts of unstructured data cheaply and reliably.

â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ User â”‚
â””â”€â”€â”¬â”€â”€â”€â”˜
   â”‚ 1ï¸âƒ£ Upload File
   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ App Server   â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ Store File
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Blob Store                   â”‚
â”‚ :contentReference[oaicite:0]{index=0} â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚ 2ï¸âƒ£ Return URL
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ App Server   â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚ 3ï¸âƒ£ Store URL
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Database     â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 4ï¸âƒ£ Replicate
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CDN Edge Nodes â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 5ï¸âƒ£ Download via CDN URL
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ User â”‚
â””â”€â”€â”€â”€â”€â”€â”˜

â¤ The pattern is simple: store the file in blob storage, get back a URL, and store that URL in your database.
â¤ Your database stays lean (it holds a URL string, not a 10MB image), and the blob storage handles durability, replication, and serving.

â¤ Blob stores are optimized for large, immutable files.
â¤ They offer high durability (S3 promises 99.999999999% durability, also known as 11 nines), cheap storage, and built-in CDN integration for fast delivery.
â¤ In system design interviews, whenever you are dealing with media (images, videos, documents), always store them in blob storage and reference them by URL in your database.

â“ We have covered where data lives and how to access it efficiently. But what happens when your system grows beyond what a single server can handle?


============
ğŸ”· Scaling
=============
Your app is growing. A single server can not handle the load anymore. What now? Scaling is about handling more traffic, more data, and more users without things falling apart.

There are two fundamental approaches, and they are not mutually exclusive.

1ï¸âƒ£ Vertical Scaling (Scale Up)
â¤ The simplest way to handle more load: get a bigger machine.
â¤ More CPU, more RAM, faster disks. That is vertical scaling. No code changes required.

            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   Ceiling     â”‚
            â”‚ Hardware Limitâ”‚
            â”‚ Cannot scale  â”‚
            â”‚ further       â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ Upgrade
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚     Large Server        â”‚
        â”‚ 64 CPU, 256GB RAM       â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ Upgrade
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚    Medium Server        â”‚
        â”‚ 8 CPU, 32GB RAM         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ Upgrade
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚     Small Server        â”‚
        â”‚ 2 CPU, 4GB RAM          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â¤ Vertical scaling is attractive because it is simple.
â¤ Your application does not need to worry about distributing work across multiple machines.
â¤ A single powerful server can handle a surprising amount of traffic, plenty for startups and small-to-medium applications.

â¤ The problem? There is a hard ceiling.
â¤ You can not keep buying bigger machines forever.
â¤ The largest cloud instances have limits, and they get disproportionately expensive.
â¤ You also have a single point of failure: if that one big server goes down, everything goes down.
â¤ That is why, beyond a certain point, you need a different approach.


2ï¸âƒ£ Horizontal Scaling (Scale Out)
â¤ Instead of making one server bigger, add more servers.
â¤ Horizontal scaling distributes the load across multiple machines, and there is no theoretical upper limit to how many you can add.

              Add more as needed
                    â–²
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚       Server N...         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚        Server 3           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚        Server 2           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚        Server 1           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â–²
                    â”‚
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚ Load Balancer â”‚
             â””â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚   Clients    â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â¤ Horizontal scaling is how every large-scale system works.
â¤ Google, Netflix, Amazon, they all run thousands of servers behind load balancers.
â¤ Adding capacity is as simple as spinning up more instances.

â¤ The catch? Your application needs to be designed for it.
â¤ Servers should be stateless, meaning any server can handle any request without relying on local state.
â¤ Session data needs to live in a shared store (like Redis), not in server memory.
â¤ You also need a load balancer to distribute traffic, and your database needs its own scaling strategy (replication, sharding).
â¤ Horizontal scaling adds complexity, but it removes the ceiling.

â“ But how do you decide which server handles each request? That is where load balancers come in.


3ï¸âƒ£ Load Balancers
A load balancer sits between clients and your server pool, distributing incoming requests so no single server gets overwhelmed.\
It is the traffic cop of your system.

                Round Robin
             Least Connections
                    â–²
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚       Load Balancer       â”‚
        â”‚   (Health Check Fails)    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚       â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Server 1    â”‚               â”‚  Server 2    â”‚
â”‚  Healthy     â”‚               â”‚  Healthy     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

            âŒ Traffic Not Sent
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  Server 3    â”‚
            â”‚  Down        â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


        â–²           â–²           â–²
        â”‚           â”‚           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Client 1  â”‚  â”‚  Client 2  â”‚  â”‚  Client 3  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â¤ Common algorithms include Round Robin (requests go to servers in order), Least Connections (send to the server handling the fewest requests), and Weighted (servers with more capacity get more traffic).
â¤ The load balancer also runs health checks: if a server stops responding, traffic is automatically routed to healthy servers.

â¤ Load balancers provide two critical benefits: scalability (distribute load across many servers) and availability (route around failures).
â¤ In system design, you will always place a load balancer in front of your application servers.
â¤ Some systems use multiple layers: one LB for web servers, another for application servers, another for databases.

â“ Load balancers distribute work across application servers. But what about the database? How do you scale reads?


4ï¸âƒ£ Replication
Replication copies your data across multiple database servers.
The most common setup is primary-replica: all writes go to the primary, and changes are replicated to one or more replicas that handle read queries.

                    Writes
                      â”‚
                      â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚  App Server  â”‚
               â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚      Primary DB        â”‚
        â”‚     Read + Write       â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚          â”‚
        Replicates    Replicates
               â”‚          â”‚
               â–¼          â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚   Replica 1    â”‚   â”‚   Replica 2    â”‚
     â”‚   Read Only    â”‚   â”‚   Read Only    â”‚
     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                     â”‚
          Reads                 Reads
            â”‚                     â”‚
            â–¼                     â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚  App Server  â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â¤ Most applications are read-heavy (think of how many times you scroll Twitter/X vs how many times you tweet).
â¤ By directing reads to replicas, you offload the primary database and can handle many times more read traffic.
â¤ If a replica fails, reads are redirected to other replicas.
â¤ If the primary fails, a replica can be promoted to take over.

â¤ The trade-off is replication lag: there is a small delay between when data is written to the primary and when it appears on replicas.
â¤ This means reads from replicas might return slightly stale data.
â¤ For most applications this is fine (your tweet appearing half a second later on someone else's feed is acceptable), but for critical operations like account balance checks, you should read from the primary.

â“ Replication handles read scaling. But what about write scaling, when a single primary cannot keep up with write volume?


5ï¸âƒ£ Sharding
â¤ Sharding splits your data across multiple database nodes, where each node holds a different subset of the data.
â¤ Unlike replication (every node has all the data), sharding means each node has only a portion.
â¤ This distributes both storage and write load.

                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚  App Server  â”‚
                     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚  Shard Router    â”‚
                   â”‚ shard_key % N    â”‚
                   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                          â”‚     â”‚     â”‚
        user_id 1-1M      â”‚     â”‚     â”‚
             â–¼            â–¼     â–¼     â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚   Shard 1    â”‚ â”‚   Shard 2    â”‚ â”‚   Shard 3    â”‚
       â”‚ user_id      â”‚ â”‚ user_id      â”‚ â”‚ user_id      â”‚
       â”‚ 1â€“1M         â”‚ â”‚ 1Mâ€“2M        â”‚ â”‚ 2Mâ€“3M        â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â¤ The shard key determines which shard holds each piece of data.
â¤ A common approach is hash-based sharding: compute a hash of the key (like user_id) and use modulo to pick a shard.
â¤ Range-based sharding assigns consecutive key ranges to each shard.
â¤ The choice of shard key is critical, a bad key creates "hot shards" where one node gets most of the traffic.

â¤ Sharding challenges include: cross-shard queries (joining data across shards is expensive), rebalancing (adding a new shard means redistributing data), and operational complexity.

ğŸ‘‰ We have covered scaling individual components.But once you are running multiple servers and databases, a new set of challenges appears.


========================
ğŸ”· Distributed Systems
========================
â¤ Once you have multiple servers, databases, and caches spread across a network, you enter the world of distributed systems.
â¤ Things that are trivial on a single machine, like keeping data consistent, become genuinely hard when machines can fail independently and networks can partition.

1ï¸âƒ£ CAP Theorem
The CAP theorem states that a distributed system can only guarantee two out of three properties: Consistency (every read returns the latest write), Availability (every request gets a response), and Partition Tolerance (the system works even if network links between nodes fail).

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     CAP Theorem    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                     â”‚                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Consistency  â”‚     â”‚ Availability â”‚     â”‚ Partition        â”‚
â”‚ Latest data  â”‚     â”‚ Always       â”‚     â”‚ Tolerance        â”‚
â”‚ always       â”‚     â”‚ responds     â”‚     â”‚ Survives network â”‚
â”‚              â”‚     â”‚              â”‚     â”‚ splits           â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                    â”‚                        â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚                    â”‚
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚  CP Systems  â”‚     â”‚  AP Systems  â”‚
               â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚                    â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ MongoDB                       â”‚     â”‚ Cassandra              â”‚
      â”‚ HBase                         â”‚     â”‚ DynamoDB               â”‚
      â”‚ Redis Cluster                 â”‚     â”‚ CouchDB                â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â¤ Since network partitions are unavoidable in distributed systems, the real choice is between CP (consistency + partition tolerance) and AP (availability + partition tolerance).

â¤ CP systems (like MongoDB, HBase) refuse to serve requests if they cannot guarantee the data is up-to-date.
â¤ Better for banking, inventory, or anything where stale data causes real problems.
â¤ AP systems (like Cassandra, DynamoDB) always respond, even if the data might be slightly stale.
â¤ Better for social media feeds, product catalogs, or analytics where availability matters more than perfect accuracy.

ğŸ‘‰ Data consistency is one challenge of distributed systems. Another is delivering content fast to users around the world.


2ï¸âƒ£ CDN (Content Delivery Network)
A CDN is a network of servers distributed across the globe that caches and serves content from locations close to users.
Instead of every request traveling to your origin server in Virginia, users get content from the nearest edge node.

                        Push Content
                             â”‚
                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Origin Server (Virginia)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚               â”‚               â”‚
         Push Content     Push Content     Push Content
                â”‚               â”‚               â”‚
                â–¼               â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Edge Node     â”‚   â”‚ Edge Node     â”‚   â”‚ Edge Node     â”‚
â”‚ London        â”‚   â”‚ Singapore     â”‚   â”‚ Mumbai        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                   â”‚                   â”‚
        â–¼                   â–¼                   â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ User UK â”‚         â”‚ User SEAâ”‚         â”‚ User Indiaâ”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â¤ CDNs primarily serve static content: images, CSS, JavaScript, videos.
â¤ Some CDNs (like CloudFlare) also cache dynamic content or run serverless functions at the edge.
â¤ The first user in a region gets a cache miss (request goes to origin), but subsequent users in that region get the cached copy, which is orders of magnitude faster.

â¤ Major CDN providers include CloudFront (AWS), Cloudflare, and Akamai.
â¤ In system design interviews, always include a CDN when your system serves media or static assets.
â¤ It reduces latency, decreases load on your origin server, and improves availability (even if your origin goes down, cached content can still be served).

â“ CDNs handle content delivery. But what about ensuring that retried requests do not cause duplicate side effects?


3ï¸âƒ£ Idempotency
â¤ In distributed systems, requests can fail and be retried.
â¤ A network timeout does not mean the request failed, maybe the server processed it but the response got lost.
â¤ If the client retries, you could end up charging a customer twice or sending duplicate emails. Idempotency prevents this.

CLIENT                                  SERVER
â”‚                                       â”‚
â”‚ POST /payments                        â”‚
â”‚ Idempotency-Key: abc-123              â”‚
â”‚ amount: $50                           â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚
â”‚                                       â”‚
â”‚                                       â”‚ Process payment
â”‚                                       â”‚ Store key abc-123
â”‚                                       â”‚ payment_id: 789
â”‚                                       â”‚
â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚ 200 OK                               â”‚
â”‚ payment_id: 789                      â”‚
â”‚                                       â”‚
â”‚ Network issue, client retries...     â”‚
â”‚                                       â”‚
â”‚ POST /payments                        â”‚
â”‚ Idempotency-Key: abc-123              â”‚
â”‚ amount: $50                           â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚
â”‚                                       â”‚
â”‚                                       â”‚ Key abc-123 already seen
â”‚                                       â”‚ Return stored result
â”‚                                       â”‚
â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚ 200 OK                               â”‚
â”‚ payment_id: 789                      â”‚
â”‚ (same result, no duplicate charge)   â”‚
â”‚                                       â”‚


â¤ An idempotent operation produces the same result regardless of how many times you execute it.
â¤ GET and DELETE are naturally idempotent (getting a resource twice returns the same thing, deleting an already-deleted resource is a no-op).
â¤ POST is not naturally idempotent, which is why you add an idempotency key: a unique identifier the client sends with each request.
â¤ The server checks if it has already processed that key and returns the cached result instead of processing again.

â¤ Stripe, PayPal, and most payment APIs require idempotency keys for exactly this reason.
â¤ In system design interviews, mention idempotency whenever you discuss payments, order creation, or any operation where duplicates would be harmful.

â“ With all these building blocks, individual concepts, how do you actually organize a large-scale system?


===========================
ğŸ”· Architecture Patterns
============================
With all the building blocks in place, from networking to storage to scaling, the final question is: how do you actually organize all these pieces into a coherent system? Architecture patterns give you proven blueprints for structuring large applications.

1ï¸âƒ£ Microservices
As applications grow, a single codebase (monolith) becomes hard to maintain, deploy, and scale.
Microservices split the application into small, independent services, each responsible for one business capability, each with its own database.

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Monolith                    â”‚
â”‚                                              â”‚
â”‚  Users + Orders + Payments + Inventory       â”‚
â”‚               (Single Codebase)               â”‚
â”‚                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚  Single DB   â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Users        â”‚      â”‚ Orders       â”‚
â”‚ Service      â”‚      â”‚ Service      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                     â”‚
       â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Users DB     â”‚      â”‚ Orders DB    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Payments     â”‚      â”‚ Inventory    â”‚
â”‚ Service      â”‚      â”‚ Service      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                     â”‚
       â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Payments DB  â”‚      â”‚ Inventory DB â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â¤ Each microservice can be developed, deployed, and scaled independently.
â¤ The payments service handling more traffic? Scale just that service. A bug in inventory? Fix and deploy it without touching anything else.
â¤ Different teams can own different services and even use different programming languages.

â¤ The downsides are real: distributed systems complexity (network calls instead of function calls), data consistency across services (no shared database means no easy joins), and operational overhead (monitoring, deploying, and debugging dozens of services).

â“ Speaking of async communication, how do services talk to each other without waiting?


2ï¸âƒ£ Message Queues
Synchronous communication (service A calls service B and waits for a response) creates tight coupling.
If service B is slow or down, service A suffers too. Message queues decouple services by introducing an intermediary that stores messages until the consumer is ready to process them.

PRODUCER / QUEUE SIDE                     CONSUMER SIDE
â”‚                                         â”‚
â”‚ 1ï¸âƒ£ Send message                         â”‚
â”‚                                         â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚ â”‚ Producer            â”‚                  â”‚
â”‚ â”‚ Order Service       â”‚                  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚           â”‚                              â”‚
â”‚           â–¼                              â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚ Message Queue                      â”‚  â”‚
â”‚ â”‚ Kafka / RabbitMQ / SQS             â”‚  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜  â”‚
â”‚           â”‚          â”‚          â”‚      â”‚
â”‚           â”‚          â”‚          â”‚      â”‚
â”‚           â–¼          â–¼          â–¼      â”‚
â”‚                                         â”‚
â”‚                         2ï¸âƒ£ Deliver when consumer ready
â”‚                                         â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚                   â”‚ Consumer         â”‚  â”‚
â”‚                   â”‚ Email Service    â”‚  â”‚
â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                         â”‚
â”‚                         2ï¸âƒ£ Deliver when consumer ready
â”‚                                         â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚                   â”‚ Consumer         â”‚  â”‚
â”‚                   â”‚ Inventory Serviceâ”‚  â”‚
â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                         â”‚
â”‚                         2ï¸âƒ£ Deliver when consumer ready
â”‚                                         â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚                   â”‚ Consumer         â”‚  â”‚
â”‚                   â”‚ Analytics Serviceâ”‚  â”‚
â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚



â¤ When a user places an order, the Order Service does not need to wait for the email to be sent, inventory to be updated, and analytics to be recorded.
â¤ It drops a message on the queue and moves on. Each downstream service picks up the message at its own pace.
â¤ If the email service is down for a minute, the messages wait in the queue and get processed when it comes back.

â¤ Message queues provide: decoupling (services do not need to know about each other), buffering (handle traffic spikes by absorbing bursts), reliability (messages persist even if consumers crash), and scalability (add more consumers to process faster).
â¤ Popular choices include Kafka (high throughput, event streaming), RabbitMQ (traditional message broker), and SQS (managed AWS service).

â“ Services are decoupled now, but every external client still needs to know the address of every service. How do you simplify that?


3ï¸âƒ£ Rate Limiting
When your API is public, or even when it is internal, you need to protect it from being overwhelmed. Rate limiting controls how many requests a client can make within a time window. It prevents abuse, protects backend services, and ensures fair usage.

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Client  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚ Request
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Rate Limiter     â”‚
â”‚   Check Counter    â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚         â”‚
     â”‚         â”‚
     â–¼         â–¼
Under limit     Over limit
150/200 used    200/200 used
     â”‚         â”‚
     â”‚         â”‚
     â–¼         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Allow        â”‚   â”‚ Reject              â”‚
â”‚ Process Req. â”‚   â”‚ 429 Too Many Req.   â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Backend      â”‚
â”‚ Server       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â¤ Common algorithms include Token Bucket (tokens refill at a fixed rate; each request costs a token), Sliding Window (count requests in a rolling time window), and Fixed Window (count requests in discrete time intervals).
â¤ The rate limiter typically sits at the API gateway level and uses a fast store like Redis to track request counts per client.

â¤ Rate limiting is essential for: preventing DDoS attacks, protecting expensive operations (like database queries), enforcing API usage tiers (free users get 100 req/min, paid users get 10,000), and ensuring one bad client does not ruin the experience for everyone else.

â“ Rate limiting is one of many cross-cutting concerns. How do you manage all of them, authentication, routing, rate limiting, without duplicating logic across every service?


4ï¸âƒ£ API Gateway
â¤ An API gateway is a single entry point for all client requests.
â¤ Instead of clients talking directly to dozens of microservices, they talk to the gateway, which handles routing, authentication, rate limiting, and other cross-cutting concerns.

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Web Client   â”‚        â”‚ Mobile App   â”‚        â”‚ 3rd Party    â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚                      â”‚                      â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚       API Gateway        â”‚
                   â”‚ Auth, Rate Limit,        â”‚
                   â”‚ Route, Transform         â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚          â”‚
                           â”‚          â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â–¼                                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Users Service  â”‚        â”‚ Orders Service â”‚   â”‚ Payments Serviceâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                           â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚ Search Service â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â¤ Without an API gateway, every service would need to implement authentication, rate limiting, and logging independently.
â¤ The gateway centralizes these concerns.
â¤ It also simplifies the client: instead of knowing the addresses of 20 services, the client knows one URL.
â¤ The gateway routes each request to the right service based on the path.

â¤ Additional gateway capabilities include: request/response transformation (converting between protocols or data formats), response aggregation (combining results from multiple services into one response), caching, and circuit breaking (stopping requests to a failing service).
â¤ Popular options include Kong, AWS API Gateway, and Nginx.


===================================
ğŸ”· Core Concepts of System Design
===================================
1ï¸âƒ£ Scalability
