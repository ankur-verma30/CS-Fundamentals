ğŸ” PHASE-0: When interviewer says: "Design Instagram"

Your brain should immediately think:
1ï¸âƒ£ Clarify requirements
2ï¸âƒ£ Identify core features
3ï¸âƒ£ High-level architecture
4ï¸âƒ£ Deep dive one feature at a time
5ï¸âƒ£ Scale & trade-offs

ğŸ” PHASE-1: Requirement Clarification
ğŸ”„ Functional Requirements (Core)

Letâ€™s explicitly say these in interview:
    âœ”ï¸ï¸ User can sign up / login
    âœ”ï¸ User can upload photos & videos
    âœ”ï¸ User can follow / unfollow users
    âœ”ï¸ User can view feed
    âœ”ï¸ User can like & comment
    âœ”ï¸ User can view profiles
ğŸ‘‰ Call this â€œMVP scopeâ€

ğŸ”„ Out of Scope
âœ”ï¸ Direct Messages - Can follow WhatsApp System Design
âœ”ï¸ Ads
âœ”ï¸ Analytics dashboard
ğŸ‘‰ This shows scope control, interviewers like this.


ğŸ”„ Non-Functional Requirements 
| Requirement         | Expectation             |
| ------------------- | ----------------------- |
| Scale               | 100M+ users             |
| Feed Latency        | < 200 ms                |
| Upload Availability | High                    |
| Read/Write          | **Read heavy**          |
| Consistency         | Eventual consistency OK |
| Reliability         | No post loss            |
ğŸ‘‰ Say explicitly: â€œFeed can tolerate eventual consistency, but uploads cannot lose data.â€


ğŸ”„ Clarifying Questions (Ask interviewer)
Ask 2â€“3:
    âœ”ï¸ Is feed chronological or ranked?
    âœ”ï¸ Do users mostly view home feed or profiles?
    âœ”ï¸ Expected daily active users?
ğŸ‘‰ Assume:
    âœ”ï¸ Chronological feed
    âœ”ï¸ Global scale


ğŸ” PHASE-2: High-Level Architecture

ğŸ”· Components
Mobile App / Web
        â†“
API Gateway
        â†“
Load Balancer
        â†“
Microservices
   â”œâ”€â”€ User Service
   â”œâ”€â”€ Post Service
   â”œâ”€â”€ Feed Service
   â”œâ”€â”€ Like/Comment Service
        â†“
Databases + Cache + Queue


ğŸ”„ Why Microservices?
â¤ Independent scaling
â¤ Different traffic patterns
â¤ Faster deployments
ğŸ‘‰ â€œFeed and Post services have very different scaling needs.â€


ğŸ” PHASE-3: Core Data Model (High-Level)
ğŸ”„ User Table
user_id (PK)
username
email
created_at


ğŸ”„ Post Table
post_id (PK)
user_id (FK)
media_url
caption
created_at


ğŸ”„ Follow Table
follower_id
following_id

ğŸ”„ Likes / Comments: Separate tables or services

ğŸ‘‰ Tech Choice
    âœ”ï¸ Metadata â†’ SQL / Cassandra
    âœ”ï¸ Media â†’ Object Storage (S3)


ğŸ” PHASE-4: Feature Deep Dive
We now go feature by feature.

ğŸ”¥ FEATURE-1: Photo Upload (DEEP DIVE)
âš¡ Flow
Client
 â†’ Upload Request
 â†’ API Server
 â†’ Object Storage (S3)
 â†’ Metadata DB
 â†’ Feed Generation Trigger


ğŸ”„ Step-by-Step
1ï¸âƒ£ Client requests pre-signed URL
2ï¸âƒ£ Client uploads directly to S3
3ï¸âƒ£ Post metadata stored in DB
4ï¸âƒ£ Event published to Kafka

ğŸ‘‰ Why pre-signed URL?
    âœ”ï¸ Avoids API server overload
    âœ”ï¸ Better scalability


ğŸ”„ Tech Used
| Component     | Tech       |
| ------------- | ---------- |
| Media Storage | AWS S3     |
| Metadata      | Cassandra  |
| Event         | Kafka      |
| CDN           | CloudFront |


ğŸ”„ Trade-off
âœ”ï¸ Eventual consistency in feed
âœ”ï¸ Upload reliability prioritized


ğŸ”¥ FEATURE-2: Feed Generation
âš¡ Two Approaches
1ï¸âƒ£ Fan-out on Write (Instagram uses this)
When user posts:
    âœ”ï¸ Push post to followersâ€™ feed
    âœ”ï¸ User Post â†’ Feed Service â†’ Followersâ€™ Feed

2ï¸âƒ£ Fan-out on Read
Generate feed at read time


ğŸ”„ Why Fan-out on Write?
| Reason              | Explanation |
| ------------------- | ----------- |
| Faster feed load    | Precomputed |
| Read heavy          | 100x reads  |
| Predictable latency | Yes         |
ğŸ‘‰ â€œSince feed reads dominate writes, we prefer fan-out on write.â€


ğŸ”„ Feed Storage
feed_user_id
post_id
timestamp

Stored in:
    âœ”ï¸ Redis (hot feed)
    âœ”ï¸ Cassandra (cold feed)


ğŸ”¥ FEATURE-3: Like & Comment
ğŸ”„ Like Flow
â¤ API â†’ Like Service
â¤ Update DB
â¤ Update cache
â¤ Async notification
ğŸ‘‰ Use idempotent APIs

ğŸ”„ Comment Flow
â¤ Stored in DB
â¤ Paginated
â¤ Indexed by post_id


ğŸ”¥ FEATURE-4: Follow System
â¤ Graph-like relationship
â¤ Stored in Cassandra
â¤ Precompute follower count


ğŸ” PHASE-5: Caching Strategy
ğŸ”„ What to Cache?
| Data          | Cache |
| ------------- | ----- |
| Feed          | Redis |
| Profile       | Redis |
| Post metadata | Redis |

ğŸ”„ Cache Invalidation
â¤ On post
â¤ On follow/unfollow


ğŸ” PHASE-6: Scalability
ğŸ”„ Horizontal Scaling
â¤ Stateless services
â¤ Auto-scaling groups

ğŸ”„ DB Scaling
â¤ Sharding by user_id
â¤ Consistent hashing


ğŸ” PHASE-7: Reliability & Fault Tolerance
â¤ Kafka retries
â¤ S3 replication
â¤ Idempotent writes
â¤ Rate limiting


ğŸ” PHASE-8: Security
â¤ JWT authentication
â¤ HTTPS everywhere
â¤ Media access via signed URLs
â¤ Rate limiting APIs


ğŸ“¸ Instagram Extension: Stories & Reels (Deep System Design)

ğŸ” PART-1: STORIES SYSTEM DESIGN
ğŸ”„ What are Stories? (Define Clearly)
â¤ Photo / video
â¤ Visible for 24 hours
â¤ Appears at top
â¤ Ordered by recency
â¤ Strong read-heavy
â¤ Ephemeral data


ğŸ”„ Functional Requirements (Stories)
â¤ User can upload story
â¤ Story auto-expires after 24 hours
â¤ Followers can view story
â¤ Track viewed / not viewed
â¤ Ordering by time


ğŸ”„ Non-Functional Requirements
| Aspect       | Requirement  |
| ------------ | ------------ |
| Latency      | Very low     |
| Consistency  | Eventual OK  |
| Storage      | Auto cleanup |
| Availability | High         |


ğŸ”¥ Story Upload Flow (Deep Dive)
âš¡ Flow
Client
 â†’ Get pre-signed URL
 â†’ Upload to Object Storage
 â†’ Metadata DB
 â†’ Story Event (Kafka)

ğŸ”„ Storage Choices
| Data         | Tech      |
| ------------ | --------- |
| Media        | S3        |
| Metadata     | Cassandra |
| Viewed State | Redis     |
| Events       | Kafka     |


ğŸ”„ Story Metadata Schema
story_id (PK)
user_id
media_url
created_at
expires_at
ğŸ‘‰ expires_at = created_at + 24h


ğŸ”¥ Story Feed Generation
â“ Fan-out or Pull?
âœ”ï¸ Hybrid Approach
â¤ Fan-out on write for small accounts
â¤ Pull model for celebrities

ğŸ‘‰ â€œFan-out explodes for users with millions of followers, so we selectively pull.â€


ğŸ”„ Story Feed Storage
story_feed_user_id
story_id
timestamp

â¤ Redis (hot)
â¤ Cassandra (cold)


ğŸ”¥ Story Expiry Handling 
âŒ DO NOT delete synchronously
âœ”ï¸ Use TTL-based deletion
â¤ Cassandra TTL
â¤ S3 lifecycle policies
â¤ Redis TTL


ğŸ”¥ Viewed / Not Viewed Tracking
ğŸ”„ Why not DB?
â¤ Extremely high writes
â¤ Per-user per-story state

âœ”ï¸ Redis Bitmap / Set
Key: story_viewed:{user_id}
Value: set(story_ids)

ğŸ” PART-2: REELS SYSTEM DESIGN
ğŸ”„ What are Reels?
â¤ Short-form videos
â¤ Discoverable (not just followers)
â¤ Ranked feed
â¤ Extremely read heavy
â¤ ML-based ranking


ğŸ”„ Functional Requirements (Reels)
â¤ Upload short videos
â¤ Infinite scrolling feed
â¤ Personalized recommendations
â¤ Likes, comments, shares
â¤ Looping playback


ğŸ”„ Non-Functional Requirements
| Aspect     | Requirement   |
| ---------- | ------------- |
| Latency    | Ultra-low     |
| Throughput | Massive       |
| Ranking    | Real-time-ish |
| CDN        | Global edge   |


ğŸ”¥ Reels Upload Flow
Same as video post but with:
    âœ”ï¸ Video processing pipeline
    âœ”ï¸ Transcoding
    âœ”ï¸ Thumbnail generation

ğŸ”„ Video Processing Architecture
Upload â†’ S3 â†’ Kafka â†’ Video Workers
                     â”œâ”€â”€ Transcode
                     â”œâ”€â”€ Generate thumbnails
                     â””â”€â”€ Store variants

ğŸ‘‰ Tech:
    âœ”ï¸ FFmpeg
    âœ”ï¸ AWS MediaConvert
    âœ”ï¸ Async workers


ğŸ”¥ Reels Feed Generation (CORE)
âŒ NOT chronological
âœ”ï¸ Ranking-based feed


ğŸ”„ Signals Used for Ranking
â¤ Watch time
â¤ Replays
â¤ Likes
â¤ Comments
â¤ Shares
â¤ Creator interaction


ğŸ”„ Reels Architecture
Client
 â†’ Reels API
 â†’ Feed Service
 â†’ Ranking Service
 â†’ Redis Cache
 â†’ Cassandra

ğŸ”„ Precomputed Buckets
â¤ Popular
â¤ Trending
â¤ Personalized

Stored in:
    âœ”ï¸ Redis
    âœ”ï¸ Updated via Kafka


ğŸ”¥ Infinite Scroll Optimization
â¤ Cursor-based pagination
â¤ Pre-fetch next batch
â¤ Cache next N reels


ğŸ” PART-3: CACHING STRATEGY (Stories + Reels)
| Component      | Cache |
| -------------- | ----- |
| Story feed     | Redis |
| Reels feed     | Redis |
| Trending reels | Redis |
| Viewed state   | Redis |


ğŸ” PART-4: SCALABILITY CHALLENGES
ğŸ”„ Stories
â¤ Fan-out explosion
â¤ TTL cleanup
â¤ View tracking

ğŸ”„ Reels
â¤ Hot content
â¤ Cache stampede
â¤ CDN pressure

ğŸ‘‰ Solutions:
    âœ”ï¸ Hybrid fan-out
    âœ”ï¸ Rate limiting
    âœ”ï¸ Regional caching


ğŸ” PART-5: FAILURE HANDLING
â¤ Kafka retries
â¤ Dead letter queues
â¤ Idempotent uploads
â¤ Graceful degradation

ğŸ¯ COMMON TRAPS
âŒ Forgetting TTL for stories
âŒ Treating reels like posts
âŒ Ignoring celebrity fan-out problem
âŒ Not mentioning video processing
